// $Id: DefaultDescription.java,v 1.1 2005/11/04 07:52:19 kevlar2 Exp $

package org.slage.parser;
import org.slage.framework.SlageFrameworkObject;

/**
 * Default implementation of a Description. Create your own Description
 * <em>only</em> if you must!
 * 
 * TODO methods to make it easier to modify a Description to add Synonyms..
 * right now it's several lines of code to do this
 * TODO kill Alter Ego
 * TODO move to framework
 * 
 * @author <a href="mailto:robert.wenner@gmx.de">Robert Wenner</a>
 */
public abstract class DefaultDescription 
    implements Description {

	private String theDescription;

	private Synonym[] synonyms;

	protected Description me;

	/** mark if this is a do-nothing description */
	private boolean bIsLame = false;

	/**
	 * Creates this Description. Convenience constructor if you have only one
	 * synonym.
	 * 
	 * @param shortDesc Short description, will be used in error messages
	 *        generated by the parser (e.g. when referring to ambiguous input)
	 * @param synonym only synonym for this Description (if there is only one
	 *        synonym).
	 */
	public DefaultDescription(String shortDesc, Synonym synonym) {
		this(shortDesc, new Synonym[] { synonym });
	}

	/**
	 * Creates this Description from given short and full descriptions.
	 * 
	 * @param shortDesc short description, usually just the name (maybe with an
	 *        adjective), like &quot;glowing gem&quot;. Should be usable as
	 *        inventory entry presented to the player or for displaying the
	 *        Description name in a tool tip. Should be unique per game.
	 * @param syns synonyms for this Description.
	 * @throws IllegalArgumentException if short description or synonyms is
	 *         missing.
	 */
	public DefaultDescription(String shortDesc, Synonym[] syns) {
		if (shortDesc == null || "".equals(shortDesc.trim())) {
			throw new IllegalArgumentException("Must have short description");
		}
		if (syns == null || syns.length == 0) {
			throw new IllegalArgumentException("Must have a synonym");
		}
		for (int i = 0; i < syns.length; i++) {
			if (syns[i] == null) {
				throw new IllegalArgumentException("Can not have null in synonyms array");
			}
		}
		theDescription = shortDesc;
		synonyms = syns;
		me = this;
	}

	public void addIfScores(BestMatch bestFit, Tokenizer input) throws WordRepeatedException {
		for (int i = 0; i < synonyms.length; i++) {
			addIfScores(bestFit, input, synonyms[i]);
		}
	}

	public abstract void addIfScores(BestMatch bestFit, Tokenizer input, Synonym synonym) throws WordRepeatedException;

	public String toString() {
		return theDescription;
	}

	public boolean equals(Object other) {
		return other instanceof Description && theDescription.equalsIgnoreCase(((DefaultDescription) other).theDescription);
	}

	public int hashCode() {
		return theDescription.hashCode();
	}

	/**
	 * Sets this Description's alter ego.
	 * 
	 * <p>
	 * To use a DefaultDescription, the game items tend to HAVE-A
	 * DefaultDescription. The game item then implements Description and delegates
	 * all Description calls to its DefaultDescription. Unfortunately, the
	 * DefaultDescription does add itself to the matching items list for the
	 * Parser, but must add its master, the actual game object. Thus, it must know
	 * about the game object, its alter ego.
	 * </p>
	 * 
	 * <p>
	 * Passing the alter ego in the constructor makes using DefaultDescription
	 * almost impossible, since Java doesn't allow using 'this' in super() calls.
	 * Hence, the user of a DefaultDescription has to reveal himself to his
	 * DefaultDescription using this method.
	 * </p>
	 * 
	 * <p>
	 * This is the first time I wished Java would allow multiple inheritance and
	 * we could just say that a game object IS-A DefaultDescription and IS-A
	 * DefaultClickParseable and IS-A GameObject and so on.
	 * </p>
	 * 
	 * @param alterEgo encapsulating the DefaultDescription.
	 * @throws NullPointerException if <code>null</code> is passed.
	 */
	public void setAlterEgo(Description alterEgo) {
		if (alterEgo == null) {
			throw new NullPointerException("Alter ego must not be null");
		}
		me = alterEgo;
	}

	/**
	 * Append another Synonym to the array.
	 * 
	 * @param syn new Synonym to add
	 */
	public void addSynonym(Synonym syn) {
		if (synonyms == null) {
			synonyms = new Synonym[] { syn };
			return;
		}

		// TODO why not hold synonyms in a Vector rather than copying them?
		Synonym[] newArray = new Synonym[synonyms.length + 1];
		System.arraycopy(synonyms, 0, newArray, 0, synonyms.length);
		newArray[synonyms.length] = syn;
		synonyms = newArray;
	}

        /** Accessor for owner object
         *  @return owner object */
	public SlageFrameworkObject getOwner() {
		return owner;
	}

	
        /** Mutator for owner object
         *  @param object owner object */
        public void setOwner(SlageFrameworkObject object) {
		this.owner = object;
		this.theDescription = object.getName();
	}

	/**
	 * The object this description belongs to, so we can track back to the object
	 * after the parser matches up
	 */
	private SlageFrameworkObject owner;

	/**
	 * Merges this Description and another.
	 * 
	 * @param desc Description to absorb.
	 */
	public void merge(DefaultDescription desc) {
		if (isLameDescription()) {
			this.synonyms = desc.synonyms;
			return;
		}
		if (desc.isLameDescription()) {
			return;
		}
		Synonym[] syns = new Synonym[this.synonyms.length + desc.synonyms.length];
		System.arraycopy(syns, 0, this.synonyms, 0, this.synonyms.length);
		System.arraycopy(syns, 0, desc.synonyms, this.synonyms.length, desc.synonyms.length);
		this.synonyms = syns;
	}

	/**
	 * Check if this is the "lame description" - we don't want to copy these in
	 * merge()
	 * 
	 * @return Value of property bIsLame.
	 */
	public boolean isLameDescription() {
		return bIsLame;
	}

	/**
	 * Set if this is the lame description
	 * 
	 * @param isLame New value of property bIsLame.
	 */
	public void setLameDescription(boolean isLame) {
		this.bIsLame = isLame;
	}
}

/*******************************************************************************
 * BEGIN LICENSE BLOCK **** Version: MPL 1.1/GPL 2.0/LGPL 2.1
 * 
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at http://www.mozilla.org/MPL/
 * 
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific language governing rights and limitations under the License.
 * 
 * The Original Code is Slage.
 * 
 * The Initial Developer of the Original Code is The SQ7.org project. Portions
 * created by the Initial Developer are Copyright (C) 2005 the Initial
 * Developer. All Rights Reserved.
 * 
 * Contributor(s): Matt Holden (Matt@sq7.org) Travis Savo (Travis@sq7.org)
 * Robert Wenner (Robert@sq7.org) Jared Cope (Jared@sq7.org) Colin Davis
 * (Colin@sq7.org)
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or the
 * GNU Lesser General Public License Version 2.1 or later (the "LGPL"), in which
 * case the provisions of the GPL or the LGPL are applicable instead of those
 * above. If you wish to allow use of your version of this file only under the
 * terms of either the GPL or the LGPL, and not to allow others to use your
 * version of this file under the terms of the MPL, indicate your decision by
 * deleting the provisions above and replace them with the notice and other
 * provisions required by the GPL or the LGPL. If you do not delete the
 * provisions above, a recipient may use your version of this file under the
 * terms of any one of the MPL, the GPL or the LGPL.
 * 
 ******************************************************************************/
